#VIRL December Webinar API Scripts

These scripts were discussed during Cisco's VIRL Webinar in December 2015 during the 'Automation and Network Programmability in VIRL' section.

The scripts are as follows:

- `curl1.sh` - extract a list of active simulations from the VIRL SimEngine
- `curl2.sh` - extract the details associated with each node running in active simulations from the VIRL Roster
- `os1.sh` - query OpenStack for the Auth-Token and Tenant-ID
- `os2.sh` - using the Auth-Token and Tenant-ID from 'os1.sh', return the list of known flavors
- `lt1.py` - start a new simulation using <file.virl> and <simulation-name> as arguments
- `st1.py` - stop the simulation named <simulation-name> provided as an argument
- `lt2.py` - start a new simulation using <file.virl> as an argument and return the simulation-name generated by the VIRL SimEngine

Please see the VIRL YouTube Channel for more information about how these scripts can be used.

### More details on os1.sh and os2.sh

The `os2.sh` example is more elaborate as it uses a token to list the Nova (compute) flavors as an example. To get the token, the `os1.sh` script is used.

1. Authenticate against the keystone service using username and password credentials. Receive an authentication token and the service catalog as a result in the header and in the body (as JSON), respectively.
2. Use the token and the service entry point to craft another request that gets the list of flavors (in this case, as an example).

Running `os1.sh` against the VIRL host retrieves a lengthy JSON object that has two important pieces of information for us:

1. the token
2. the endpoint URL

Here's some (abridged) sample output

	{
	    "access": {
	        "metadata": {
	            "is_admin": 0,
	            "roles": [
	                "9a9040b6a91042899672432638722c3a"
	            ]
	        },
	        "serviceCatalog": [
	            {
	                "endpoints": [
	                    {
	                        "adminURL": "http://127.0.1.1:8774/v2/774f2d67cd0d4c829f3cbcedb026ee83",
	                        "id": "7ff677debdfc4e4fb86d7dad3caef1b9",
	                        "internalURL": "http://127.0.1.1:8774/v2/774f2d67cd0d4c829f3cbcedb026ee83",
	                        "publicURL": "http://127.0.1.1:8774/v2/774f2d67cd0d4c829f3cbcedb026ee83",
	                        "region": "RegionOne"
	                    }
	                ],
	                "endpoints_links": [],
	                "name": "nova",
	                "type": "compute"
	            },
			[...]
	        ],
	        "token": {
	            "audit_ids": [
	                "hp3vylbnQlOjWPDn7fCg8Q"
	            ],
	            "expires": "2015-12-15T23:23:28Z",
	            "id": "df696d8ad22b41bcb5102a3be13e2ff8",
	            "issued_at": "2015-12-15T22:23:28.669961",
	            "tenant": {
	                "description": null,
	                "enabled": true,
	                "id": "774f2d67cd0d4c829f3cbcedb026ee83",
	                "name": "admin"
	            }
	        },
	        "user": {
	            "id": "db04f92437e6400a95ca0344acd2bfc6",
	            "name": "admin",
	            "roles": [
	                {
	                    "name": "admin"
	                }
	            ],
	            "roles_links": [],
	            "username": "admin"
	        }
	    }
	}



And then both information pieces go into the `os2.sh` script. The idea here really is to grab the various pieces together to retrieve information using an authentication token.

**Putting it together**

The token and the endpoint URI are reflected in this example (the `os2.sh` script will not work on other systems unmodified):

	#!/bin/bash
	
	HOST="172.16.1.1"
	
	curl -s -H "X-Auth-Token: df696d8ad22b41bcb5102a3be13e2ff8" \
	            http://$HOST:8774/v2/774f2d67cd0d4c829f3cbcedb026ee83/flavors  \
				| python -m json.tool

You'll get the idea :-)